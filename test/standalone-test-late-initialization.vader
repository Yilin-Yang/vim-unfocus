Include: WindowHelpers.vader

Execute (Declare Helper Functions):

  " Verify that the settings of a focused window have been set correctly.
  function! CheckFocusedSettings(wininfo, initial_settings) abort
    let l:expected = copy(g:on_focus)
    call extend(l:expected, a:initial_settings, 'keep')

    let l:cur_vars_and_vals = a:wininfo.GetVals(g:watched_settings)
    call AssertSettingsEqual(l:expected, l:cur_vars_and_vals, a:wininfo.winid, 'focused')
  endfunction

  " Verify that the settings of an unfocused window have been set correctly
  " after a late initialization.
  "
  " Late initialization of an unfocused window will "forcibly" set the focused
  " settings for that window while *using its current settings values as its
  " unfocused settings.*
  function! CheckUnfocusedSettings(wininfo, initial_settings) abort
    let l:expected = copy(g:on_unfocus)
    call extend(l:expected, a:initial_settings, 'force')

    let l:cur_vars_and_vals = a:wininfo.GetVals(g:watched_settings)
    call AssertSettingsEqual(l:expected, l:cur_vars_and_vals, a:wininfo.winid, 'unfocused')
  endfunction

  let g:setting_is_str = {}
  for g:setting in ['&number', '&relativenumber', '&foldcolumn']
    execute 'let g:setting_is_str[g:setting] = '
        \ .'maktaba#value#IsString('.g:setting.')'
  endfor
  lockvar g:settings_to_types


  " For some reason, neovim returns numeric setting values as strings
  " where vim returns numbers. This breaks vader's AssertEqual type
  " comparison.
  "
  " Given a setting name (number, relativenumber, or foldcolumn),
  " take a value for that setting, and return it as a string or number
  " depending on what nvim/vim would return.
  function! FixType(setting_name, value) abort
    return g:setting_is_str[a:setting_name] ? string(a:value) : a:value
  endfunction


Execute (Setup):
  let g:plugin = maktaba#plugin#Get('vim-unfocus')
  " disable autocmds, build windows, reenable autocmds, make sure that
  " focus/unfocus settings are populated correctly
  call g:plugin.flags.plugin.Set({'autocmds': 0})

  let g:on_focus = {
      \ '&number': FixType('&number', 1),
      \ '&relativenumber': FixType('&relativenumber', 1),
      \ '&foldcolumn': FixType('&foldcolumn', 3),
    \ }
  let g:on_unfocus = {
      \ '&number': FixType('&number', 0),
      \ '&relativenumber': FixType('&relativenumber', 0),
    \ }

  call g:plugin.Flag(
      \ 'to_set', {
        \ 'on_unfocus': g:on_unfocus,
        \ 'on_focus': g:on_focus,
      \ })

  let g:watched_settings = sort(['&number', '&relativenumber', '&foldcolumn'])

  let g:tabs_to_wins = {}
  let g:kVaderTab = tabpagenr()

  tabnew
  let g:this_tab_nr = g:kVaderTab + 1
  let g:this_tab = []
  call add(g:this_tab, MakeWindowWith(
      \ {'&number': FixType('&number', 0),
      \  '&relativenumber': FixType('&relativenumber', 1),
      \  '&foldcolumn': FixType('&foldcolumn', 2)}))
  call add(g:this_tab, MakeWindowWith(
      \ {'&number': FixType('&number', 1),
      \  '&relativenumber': FixType('&relativenumber', 0),
      \  '&foldcolumn': FixType('&foldcolumn', 1)}))
  call add(g:this_tab, MakeWindowWith(
      \ {'&number': FixType('&number', 0),
      \  '&relativenumber': FixType('&relativenumber', 0),
      \  '&foldcolumn': FixType('&foldcolumn', 1)}))
  let g:tabs_to_wins[g:this_tab_nr] = g:this_tab
  unlet g:this_tab

  tabnew
  let g:this_tab_nr += 1
  let g:this_tab = []
  call add(g:this_tab, MakeWindowWith(
      \ {'&number': FixType('&number', 0),
      \  '&relativenumber': FixType('&relativenumber', 1),
      \  '&foldcolumn': FixType('&foldcolumn', 2)}))
  call add(g:this_tab, MakeWindowWith(
      \ {'&number': FixType('&number', 0),
      \  '&relativenumber': FixType('&relativenumber', 1),
      \  '&foldcolumn': FixType('&foldcolumn', 1)}))
  call add(g:this_tab, MakeWindowWith(
      \ {'&number': FixType('&number', 1),
      \  '&relativenumber': FixType('&relativenumber', 0),
      \  '&foldcolumn': FixType('&foldcolumn', 10)}))
  let g:tabs_to_wins[g:this_tab_nr] = g:this_tab
  unlet g:this_tab

  tabnew
  let g:this_tab_nr += 1
  let g:this_tab = []
  call add(g:this_tab, MakeWindowWith(
      \ {'&number': FixType('&number', 0),
      \  '&relativenumber': FixType('&relativenumber', 1),
      \  '&foldcolumn': FixType('&foldcolumn', 2)}))
  call add(g:this_tab, MakeWindowWith(
      \ {'&number': FixType('&number', 0),
      \  '&relativenumber': FixType('&relativenumber', 1),
      \  '&foldcolumn': FixType('&foldcolumn', 1)}))
  let [g:very_last_win, g:very_last_initial_settings] =
      \ MakeWindowWith(
          \ {'&number': FixType('&number', 1),
          \  '&relativenumber': FixType('&relativenumber', 0),
          \  '&foldcolumn': FixType('&foldcolumn', 10)})
  call add(g:this_tab, [g:very_last_win, g:very_last_initial_settings])
  let g:tabs_to_wins[g:this_tab_nr] = g:this_tab
  unlet g:this_tab


Execute (Enable Autocmds):
  " make sure that the last window is still open, to test registration of the
  " currently active window
  call g:very_last_win.Goto()
  AssertEqual g:very_last_win.winid, win_getid()

  " this should activate a callback that will register all open windows
  call g:plugin.flags.plugin.Set({'autocmds': 1})


Execute (Check Window Settings):
  " focus each window, verify that its focused settings were set properly, and
  " verify that the previously focused window had its unfocused settings set
  " properly

  " handle the very first window and very last windows as special cases;
  " the last window should have remained focused when we reactivated autocmds,
  " so its current window values should have been treated as focused settings,
  " while its unfocused settings should have been forcibly initialized to
  " *exactly* match the user's unfocus settings.
  let g:tab_idx = g:kVaderTab + 1
  let g:cur_wins_and_settings = g:tabs_to_wins[g:tab_idx]
  let [g:cur_win, g:initial_settings] = Pop(g:cur_wins_and_settings)
  let [g:first_win, g:first_initial_settings] = [g:cur_win, g:initial_settings]

  " special case: first window and last window
  call g:cur_win.Goto()
  call CheckFocusedSettings(g:cur_win, g:initial_settings)

  while has_key(g:tabs_to_wins, g:tab_idx)
    let g:cur_wins_and_settings = g:tabs_to_wins[g:tab_idx]
    while len(g:cur_wins_and_settings)
      let g:last_win = g:cur_win
      let g:last_initial_settings = g:initial_settings

      let [g:cur_win, g:initial_settings] = Pop(g:cur_wins_and_settings)

      call g:cur_win.Goto()
      if g:cur_win isnot g:very_last_win
        call CheckFocusedSettings(g:cur_win, g:initial_settings)
      else
        let g:expected = copy(g:on_focus)
        call extend(g:expected, g:very_last_initial_settings, 'force')
        call AssertSettingsEqual(
            \ g:expected, g:very_last_win.GetVals(g:watched_settings),
            \ g:very_last_win.winid, 'focused')
      endif
      call CheckUnfocusedSettings(g:last_win, g:last_initial_settings)

    endwhile
    let g:tab_idx += 1
  endwhile

  " special case: last window
  call g:first_win.Goto()
  call CheckFocusedSettings(g:first_win, g:first_initial_settings)

  let g:last_win = g:cur_win
  let g:last_initial_settings = g:initial_settings

  " as explained above, the user's unfocus settings "took priority"
  " when the last window's FocusSettings were initialized
  call AssertSettingsEqual(
      \ extend(g:last_initial_settings, g:on_unfocus, 'force'),
      \ g:last_win.GetVals(g:watched_settings),
      \ g:last_win.winid,
      \ 'unfocused')
